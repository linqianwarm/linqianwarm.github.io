[{"title":"vue常用组件集合","date":"2019-01-30T10:41:12.000Z","path":"2019/01/30/vue常用组件集合/","text":"一.视频播放 二.图片预览 三.复制 一.视频播放 vue-video-player基于video.js，文档 api 都可以参照api doc / options12345678910111213141516171819&lt;video-player class=&quot;video-player-box&quot; ref=&quot;videoPlayer&quot; :options=&quot;playerOptions&quot; :playsinline=&quot;true&quot; customEventName=&quot;customstatechangedeventname&quot; @play=&quot;onPlayerPlay($event)&quot; @pause=&quot;onPlayerPause($event)&quot; @ended=&quot;onPlayerEnded($event)&quot; @waiting=&quot;onPlayerWaiting($event)&quot; @playing=&quot;onPlayerPlaying($event)&quot; @loadeddata=&quot;onPlayerLoadeddata($event)&quot; @timeupdate=&quot;onPlayerTimeupdate($event)&quot; @canplay=&quot;onPlayerCanplay($event)&quot; @canplaythrough=&quot;onPlayerCanplaythrough($event)&quot; @statechanged=&quot;playerStateChanged($event)&quot; @ready=&quot;playerReadied&quot;&gt; &lt;/video-player&gt;注：1.播放按钮居中，在组件标签中加入【vjs-big-play-centered】class12&lt;video-player class=&quot;video-player-box vjs-big-play-centered&quot;&gt;&lt;/video-player&gt;2.禁止在 iPhone safari 中自动全屏1:playsinline=&quot;true&quot;3.暂停时显示播放按钮1234.vjs-paused .vjs-big-play-button,.vjs-paused.vjs-has-started .vjs-big-play-button &#123; display: block;&#125;4.显示当前播放时间12.video-js .vjs-time-control&#123;display:block;&#125;.video-js .vjs-remaining-time&#123;display: none;&#125;暂时未解决问题：点击播放中的视频暂停二.图片预览vue-photo-preview ，配置文档 配置文档同PhotoSwipe常见使用：123456789import preview from &apos;vue-photo-preview&apos;;import &apos;vue-photo-preview/dist/skin.css&apos;;let previewOpts = &#123;fullscreenEl: false, //右上角的全屏 buttonzoomEl: false,//右上角的放大 buttontapToClose: true, //点击关闭，体验为佳最好加上&#125;;Vue.use(preview, previewOpts);问题：1.异步加载数据，无法点击预览12this.\\$previewRefresh();一些样式覆盖12345678//样式覆盖//关闭按钮放大.pswp**button.pswp**button--close&#123;top: 20px;right: 20px;transform: scale(3);&#125; 三.复制组件 vue版本guild &amp; samplejs版本 ps: IOS10以下版本不支持，建议在代码中做onerr处理其他版本兼容问题可以参照GitHub上的【Browser Support】 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;template id=&quot;t&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;button type=&quot;button&quot; v-clipboard:copy=&quot;message&quot; v-clipboard:success=&quot;onCopy&quot; v-clipboard:error=&quot;onError&quot; //加上对不兼容设备的处理 &gt;Copy!&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, template: &apos;#t&apos;, data: function () &#123; return &#123; message: &apos;Copy These Text&apos; &#125; &#125;, methods: &#123; onCopy: function (e) &#123; alert(&apos;You just copied: &apos; + e.text) &#125;, onError: function (e) &#123; alert(&apos;Failed to copy texts&apos;) &#125; &#125;&#125;)&lt;/script&gt; `","tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]},{"title":"JavaScript里的土豆是真是假？","date":"2017-07-12T11:18:41.000Z","path":"2017/07/12/JavaScript里的土豆是真是假？/","text":"本翻译同时发布在平台众成翻译附上原文链接PS: 本文的一些点经常容易忘记，收藏一下随时来看看哦 你没有必要因为自己是一个JavaScript初学者而被以下这些迷惑… 1234if ([0]) &#123; console.log([0] == true); //false console.log(!![0]); //true&#125; 或者这样… 1234if (&quot;potato&quot;) &#123; console.log(&quot;potato&quot; == false); //false console.log(&quot;potato&quot; == true); //false&#125; 好消息是，所有浏览器都得遵循一个标准。 有些作者会告诉你害怕胁迫和写码反对它。 我希望说服你，强制规则的特征我们可以利用（或至少理解），而不是去逃避… x是true吗？x等于y？真假问题和等于运算，属于JavaScript的三个主要领域的核心问题：条件语句与运算符（if，三目运算，&amp;&amp;，||等），等于运算符（==）和严格相等运算符（===）。 让我们看看在每种情况下会发生什么… 条件语句Conditionals在JavaScript中，所有条件语句和运算符都遵循相同的强制模式。 我们将以if语句为例。 构造if（表达式）_声明将强制使用抽象方法将表达式_转换为布尔值，在 ES5 spec中定义了以下算法规则： 参数类型 结果 Undefined false Null false Boolean 结果等于输入参数（无转换） Number 如果参数为+0，-0或NaN，结果为false;否则结果是true String 如果参数是空字符串（其长度为零），则结果为false。否则结果为true。 Object true 这是JavaScript用于将值分类为true（true，“potato”，36，[1,2,4]和{a：16}）或false（false ，0，&quot;&quot;，null和undefined）。 现在我们知道了为什么，在之前介绍的例子中，if（[0]）允许进入后面的块：一个数组是一个对象，所有的对象被强制转换为true。 以下还有几个例子。 一些结果可能令人惊讶，但他们始终坚持上述规定的简单规则： 1234567891011121314var trutheyTester = function(expr) &#123; return expr ? &quot;truthey&quot; : &quot;falsey&quot;; &#125;trutheyTester(&#123;&#125;); //truthey (一个object永远都是true)trutheyTester(false); //falseytrutheyTester(new Boolean(false)); //truthey (一个object!)trutheyTester(&quot;&quot;); //falseytrutheyTester(new String(&quot;&quot;)); //truthey (一个object!)trutheyTester(NaN); //falseytrutheyTester(new Number(NaN)); //truthey (一个object!) 等于运算(==)这个两个等号‘==’版本规则是相当宽松的。 即使左右两边是不同的类型，值也可以被认为是相等的，因为在执行比较之前，操作者将强制将一个或两个比较者转换为单一类型（通常为数字）。许多开发人员有点担心这种操作，无疑这至少有一个知名的JavaScript大师，会建议大家避免使用==操作符。 这种避免策略让我烦恼，因为除非你完全知道理解它，你才能掌握这种语言，而恐惧和逃避是知识的敌人。 另外假装忽略‘==’的存在并不会让你感到轻松了，因为在JavaScript强制转换是无处不在的！它在条件表达式（如我们刚刚看到的）中，它在数组索引中，它在连接操作处等等。 更强大的是，当我们能安全地使用它时，可以写出简洁，优雅和可读性高的代码。 无论如何，让我们看看ECMA定义的‘==’如何运作的方式。 它真的不是那么吓人。 只要记住undefined和null彼此相等（而没有别的），大多数其他类型被强制到一个数字以便于比较： Type(x) Type(y) Result x、y 相同类型 x、y 相同类型 请参阅严格平等（===）算法 null Undefined true Undefined null true Number String x == toNumber(y) String Number toNumber(x) == y Boolean (any) toNumber(x) == y (any) Boolean x == toNumber(y) String or Number Object x == toPrimitive(y) Object String or Number toPrimitive(x) == y 其他的类型组合 其他的类型组合 false 其中结果是表达式，则重新应用算法，直到结果为布尔值。 toNumber和toPrimitive是根据以下规则转换参数的js内部方法： ToNumber 参数类型 结果 Undefined NaN Null +0 Boolean 如果参数是true结果为 1 .如果参数是false结果为 +0 . Number 结果等于输入（无转化） String 有效计算Number(string) “abc” -&gt; NaN“123” -&gt; 123 Object 遵循以下步骤:1. 让 primValue进行 ToPrimitive(input argument, hint Number).2. 返回 ToNumber(primValue). ToPrimitive 参数类型 Result Object （在等于运算符强制转换的情况下）如果valueOf返回一个原始值，则返回它。如果不是，则进行toString，如果返回一个原始值，则返回。 否则会出错 其他 结果等于输入参数 (没有转换). 这里有一些例子 —— 我将使用代码逐步演示如何应用各种强制转换规则 [0] == true; 123456789101112//‘等于’检查...[0] == true; //看看是怎样运作的...//对boolean使用toNumber转换[0] == 1;//对object使用toPrimitive转换//[0].valueOf() 返回并不符合原始类型primitive，继续...//[0].toString() 返回 &quot;0&quot;&quot;0&quot; == 1; //对左边的string使用toNumber转换0 == 1; //false! “potato” == true; 12345678//校验是否等于...&quot;potato&quot; == true; //运作方式...//对boolean使用toNumber转换&quot;potato&quot; == 1;//对string使用toNumber转换NaN == 1; //false! “potato” == false; 12345678//校验是否等于...&quot;potato&quot; == false; //运作方式...//对boolean使用toNumber转换&quot;potato&quot; == 0;//对string使用toNumber转换NaN == 0; //false! object使用valueOf 123456789//校验是否等于...crazyNumeric = new Number(1); crazyNumeric.toString = function() &#123;return &quot;2&quot;&#125;; crazyNumeric == 1;//运作方式...//对object使用toPrimitive转换//valueOf返回了一个primitive，所以我们用它1 == 1; //true! object使用toString 123456789101112//校验是否等于...var crazyObj = &#123; toString: function() &#123;return &quot;2&quot;&#125;&#125;crazyObj == 1; //运作方式...//对object使用toPrimitive转换//valueOf返回一个object，所以使用toString&quot;2&quot; == 1;//对string使用toNumber转换2 == 1; //false! 严格相等运算符 (===)这个很容易.如果运算符左右的类型不同，结果总是false。 如果它们是同一类型，则应用直观的等式测试：对象标识符必须引用相同的对象，字符串必须包含相同的字符集，其他原语必须共享相同的值。 NaN，null和undefined永远不会===另一个类型。 NaN甚至不===本身。 类型(x) 值 结果 类型(x) 与 类型(y)不同 false Undefined or Null true Number x 和 y 值相同 (但是不是NaN) true String x 和 y 为相同字符 true Boolean x 和 y 都是true或者false true Object x 和 y 引用同一个对象 true 其他情况… false 一些使用等于判断不佳的例子 12345//没必要if (typeof myVar === &quot;function&quot;);//更好if (typeof myVar == &quot;function&quot;); ..因为 typeOf 是返回一个字符串的, 所以这个等于运算符总是在比较两个字符串. 因此 == 是 100% 的全等于。 12345//没必要var missing = (myVar === undefined || myVar === null);//更好var missing = (myVar == null); …null 和 undefined 是始终等于（==）自己或对方的. 注意：由于undefined变量可能被重新定义（非常小）的风险，所以等于null是稍微更安全的。 12345//没必要if (myArray.length === 3) &#123;//..&#125;//更好if (myArray.length == 3) &#123;//..&#125; …不用我再解释，大家一定都懂啦 😉","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"电钢小白——《梦中的婚礼》","date":"2017-07-11T11:26:57.000Z","path":"2017/07/11/电钢小白——《梦中的婚礼》/","text":"","tags":[{"name":"colorful life","slug":"colorful-life","permalink":"http://yoursite.com/tags/colorful-life/"}]},{"title":"编写模块化的CSS（第二部分）—命名空间 | Zell Liew","date":"2017-06-15T11:12:33.000Z","path":"2017/06/15/编写模块化的CSS（第二部分）—命名空间-Zell-Liew/","text":"本翻译同时发布在平台众成翻译附上原文链接PS: 本文还有1和3，建议宝宝们看这个之前先看1；还有链接3 上周，我分享了如何使用BEM创建一个合理的CSS架构。 虽然BEM很棒，但它只是解决方案的一部分。 还有另一部分我还没有提到 - 命名空间。 在今天的这篇文章中，我想与大家分享一下为什么只用BEM还是不够的，以及如何使用命名空间来弥补一些不足。 为什么BEM不能满足我们我上周给大家展示的例子很简单。 我只向大家展示了如何处理单个块中不同的修饰符和子代（或孙子代）元素。 但是如果有多个区块咱怎么办呐？ 事情有点复杂。 我们使用一个网站范围的导航来说明两个块之间的关系。 1234&lt;nav class=&quot;main-nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;button class=&quot;button&quot;&gt;Menu&lt;/button&gt;&lt;/nav&gt; 好啦。 现在有两个区块。 一个叫.main-nav，另一个叫.button。 .button存在于.main-nav内。 然后现在你想把这个button的颜色从blue变成green。同时你也想给.button加些左边距来和home链接分开。 那么问题来了，你应该怎样书写CSS代码呢？这下面有几种可能的答案： 1.给.main-nav .button添加margin和background-color。 2.给button--modifier添加margin和background-color。 3.给.main-nav .button添加margin，给button--modifier添加background-color。 4.给.main-nav a添加margin，给.main-nav .button添加background-color。 5.给.main-nav a添加margin，给button--modifier添加background-color。 哪一种方式最能引起你的情感共鸣呢？ 你又如何能确保您的项目中的每个开发人员都以同样的方式来接受呢？ 即使您的所有开发人员都拷贝了这个方案（因此也是以同样的方式），您如何知道您是否没有引入副作用（破坏了网站的另一部分）？😱😱😱 老实说，很难保证！如果我们只有BEM，有太多可能的因素导致。 这就是之所以引入命名空间。它可以帮助你创建一个结构来控制CSS属性的写入。 如果您遵循惯例，您将能够无惧副作用地编写CSS。 这里是一个示例。 假设我把上面的代码转换成一个带有命名空间的代码。HTML将完全相同（只加了少数的class前缀）。 在这个例子中要特别注意.o和.c前缀： 1234&lt;nav class=&quot;c-main-nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;button class=&quot;o-button&quot;&gt;Menu&lt;/button&gt;&lt;/nav&gt; .o-和.c-是什么意思呢？从这个代码来看，我知道如果我想，我可以改变.o-button的颜色，但我不应该添加任何边距到.o-button。 啥！？ 那么我必须来解释这些命名空间，gogogo~ :) 我使用的命名空间以下是我使用的命名空间列表： .l-: 布局(layouts) .o-: 对象(objects) .c-: 组件(components) .js: js的钩子(JavaScript hooks) .is-|.has-: 状态类(state classes) .t1|.s1: 排版大小(typography sizes) .u-: 实用类(utility classes) 我们来看看具体每个命名空间是什么，以及咱应该怎么用。 在继续之前，如果您对命名空间不了解，我强烈建议您查看Harry Robert的具有命名空间的更透明的ui代码。（有趣的事实：Harry启发我使用命名空间）。 如果你阅读Harry的文章，要注意一下我的命名空间不同于他的。（待会儿我会分享有哪些不同的内容）。 以上，让我们先进入第一个命名空间——布局（layouts） “.l-”——布局(layouts)我很确定你听说过Nicole Sullivan的Object Oriented CSS(面向对象的CSS)(OOCSS)。 如果您还没有深入了解，那得知道OOCSS背后的主要思想是表层和结构的分离。 换句话说，影响块或其元素的位置的属性应该被抽象为一个单独的类用于重复利用。 在CSS中，定位块的行为也称为布局块。 在一般意义上，定位是布局。 也许这只是一个快乐的巧合（也许😉），但Jonathan Snook在SMACSS中为布局规则建议一个.l-前缀。这两个范例在布局方面有着相同的原则。 因此，我很高兴地从SMACSS中窃取.l-作为布局命名空间。 既然你已经了解了命名空间的起源了，它可能会帮助你了解它的使用方式。 当涉及到布局时，我将布局分为两个不同的类别 —— 全局布局和块级布局。 全局布局全局布局是应用于所有页面的布局。 (😑)。 在我的用例中，它们通常是在任何地方都使用的大型网格容器。 一个例子是.l-wrap class： 1234567891011// I like to write in Sass :).l-wrap &#123; padding-left: 1em; padding-right: 1em; @media (min-width: 1000px) &#123; max-width: 800px; margin-left: auto; margin-right: auto; &#125;&#125; 我将在每个地方都使用.l-wrap class，比如在header和footer里来对齐内容： 1234567891011&lt;div class=&quot;site-header&quot;&gt; &lt;div class=&quot;l-wrap&quot;&gt; &lt;!-- stuff --&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;site-footer&quot;&gt; &lt;div class=&quot;l-wrap&quot;&gt; &lt;!-- stuff --&gt; &lt;/div&gt;&lt;/div&gt; 由于这些class在全局使用，所以我更喜欢把它们写在_layouts.scss部分。 块级布局每个块（对象或组件，我们将在后面讨论）可能有自己的布局。 通过个人经验，我发现这些布局通常独立于全局布局。 让我来举个栗子。 当我为Mastering Responsive Typography建站后，我添加了一个如下所示的付款表单： 响应式排版的付款表单 在上面的设计中，您可以看到该表单包含两行输入元素。 第一行中有两个相等大小的输入框，第二行中有两个不同大小的输入框。 为了区分这三个不同大小的输入框，我选择了布局前缀： 1234567891011&lt;form class=&quot;form l-form&quot; action=&quot;#&quot;&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;div class=&quot;form__item l-form__item--large&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item--small&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt;&lt;/form&gt; 你注意到了我是怎样同时保持BEM的实现还有布局的？ 这种实现对我来说使我更加清楚了。 你瞄一眼就可以看到我的CSS将写些啥。 清晰明了。 1234.l-form &#123;/* container styles */&#125;.l-form__item &#123;/* half-width styles */&#125;.l-form__item--large &#123;/* larger-width styles */&#125;.l-form__item--small &#123;/* smaller-width styles */&#125; 因为.l-form，.l-form__item，.l-form__item - small和.l-form__item - large与其他块无关，我在_form.scss中写这些class来保持上下文。 顺便说一句，有些人不同意我在前一篇文章里讲到当出现.block - modifier时删除.block这一观点。 那么，看看在这种情况下插入所有“必需”BEM class的情况下会发生什么，你会注意到“HTML开始膨胀”： 123456789101112&lt;form class=&quot;form l-form&quot; action=&quot;#&quot;&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;!-- 这段HTML开始变得太太太太长了 😢 --&gt; &lt;div class=&quot;form__item l-form__item l-form__item--large&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item l-form__item--small&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt;&lt;/form&gt; 最后一点：Harry使用对象命名空间（.o-）来表示这样的结构布局。 我只是将它们分组成.l-，并使用.o-来代替别的东西。 以上，让我们转移到对象（objects）上(我的版本 😜)。 “.o-”——对象(Objects)Objects(.o-)是website的最小构建块。可以把它们想成是可以在网站各个地方拼凑的【乐高】块（译者注：‘乐高’玩具，没玩过的可以淘宝搜看看）。 如果您曾听过Brad Frost的Atomic Design，也可以将对象视为元素和分子的混合物。 对象物们都有着以下的属性： 对象使用.o-前缀 它们的里面不能包含其他对象或组件 它们之于上下文是独立的 某些对象可以在有意义的情况下忽略.o-前缀。 对象不能包含其他对象或组件对象可大可小。对象中的HTML元素的数量是不相关的。 解释以下。 举个例子,buttons就是对象。它们是很小的而且可以放到任何地方。这是不言而喻的： 1`&lt;a href=&quot;#&quot; class=&quot;o-button&quot;&gt;A button&lt;/a&gt;` 一个较大的对象的例子是我为Mastering Responsive Typography构建的倒计时器： 一个大对象的例子。仍然被认为是一个对象，因为它不包含对象和组件。 倒计时器的HTML结构如下： 123456789101112131415161718&lt;div class=&quot;o-countdown jsCountdown&quot;&gt; &lt;div class=&quot;o-countdown__inner&quot;&gt; &lt;span data-token=&quot;days&quot;&gt;1&lt;/span&gt; &lt;span&gt;day&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner&quot;&gt; &lt;span data-token=&quot;hours&quot;&gt;21&lt;/span&gt; &lt;span&gt;hours&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner&quot;&gt; &lt;span data-token=&quot;minutes&quot;&gt;41&lt;/span&gt; &lt;span&gt;minutes&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner&quot;&gt; &lt;span data-token=&quot;seconds&quot;&gt;50&lt;/span&gt; &lt;span&gt;seconds&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 注意.o-countdown包含三层HTML元素。虽然它很大了，但它仍然是一个对象，因为它不包含任何其他对象或组件。.o-countdown中的元素的实际数量是无关紧要的，因为所有内部元素只能在.o-countdown里存在。 对象独立于上下文当我说对象是上下文独立的时候，我的意思是他们不知道在哪里会被使用。 你可以选择任何的对象，并把它放在你喜欢的地方，而且并不会破坏你的网站的结构。 这也意味着对象不应该更改外部任何结构。 因此，对象块不能包含任何这些属性/值： absolute 和 fixed 定位。 margin padding (除非你用了background-color。 在这种情况下，它不会中断对象外部的对齐)。 float. 等等… 既然你知道对象需要与上下文无关，你马上知道我们站点范围的导航示例中的.button不能包含任何边距。 以下是我的样式表中典型的.o-button对象的示例： 1234567891011/* 如果您不明白这个棘手的选择器，请返回上一篇文章理解 */[class*=&apos;o-button&apos;]:not([class*=&apos;o-button__&apos;]) &#123; display: inline-block; padding: 0.75em 1.25em; border-radius: 4px; background-color: green; color: white; font-size: inherit; line-height: inherit; transition: all 0.15s ease-in-out;&#125; 虽然对象不能影响外部结构，但它改变其内部结构是很合理的。 例如，我提到的.o-countdown计时器可以具有以下HTML和CSS： 123456789101112131415161718&lt;div class=&quot;o-countdown l-countdown jsCountdown&quot;&gt; &lt;div class=&quot;o-countdown__inner l-countdown__inner&quot;&gt; &lt;span data-token=&quot;days&quot;&gt;3&lt;/span&gt; &lt;span&gt;days&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner l-countdown__inner&quot;&gt; &lt;span data-token=&quot;hours&quot;&gt;20&lt;/span&gt; &lt;span&gt;hours&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner l-countdown__inner&quot;&gt; &lt;span data-token=&quot;minutes&quot;&gt;57&lt;/span&gt; &lt;span&gt;minutes&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;o-countdown__inner l-countdown__inner&quot;&gt; &lt;span data-token=&quot;seconds&quot;&gt;33&lt;/span&gt; &lt;span&gt;seconds&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1234567.l-countdown &#123; display: flex;&#125;.l-countdown__inner &#123; /* 大概你想咋整就咋整? */&#125; 你可以自由地设计一个对象，底线是只要它不影响任何外面的东西。（另外，请确保您不要意外添加’padding’使其看起来不规整）。 合理情况下，某些对象可以忽略 .o- 前缀哇，我们是否已经违反了规定？ 哎是呀！😈。 一些对象包含.o-前缀（甚至是一个类）本身就没有意义，因为它们被使用得太多了。 举一个这样的例子——输入元素： 1`&lt;input type=&quot;text&quot;&gt;` 当然，如果你喜欢的话，你可以将一个class标记给input，但是如果你不能访问 1234567891011121314@mixin input &#123; padding: 0.5em 0.75em; font-size: inherit; line-height: inherit; font-family: inherit;&#125;input[type=&quot;text&quot;],input[type=&quot;email&quot;],input[type=&quot;textarea&quot;] &#123; @include input;&#125;// ... 我觉得另一个对象不应该使用.o-前缀的例子是字体。 他们得到特别待遇（我稍后会解释）。 在这一点上，你可以自由地反对。 对象使用总结对象（.o-）是一个网站的最小的构建块。对象物们都有着以下的属性： 对象使用.o-前缀 它们的里面不能包含其他对象或组件 它们之于上下文是独立的 某些对象可以在有意义的情况下忽略.o-前缀。 接下来我们转移到组件上 “.c-”——组件(Components)如果对象是最小的构建块，则组件是您可以在整个站点中使用的更大的构建块。 如果您已阅读《原子设计》，请将组件视为有机体。 （除了这种生物体可以含有其他生物体 😉)。 组件有着以下属性： 组件使用’.c-‘前缀 组件可以包含其他对象和组件。 组件是上下文感知的 让我们来看看这些属性，我会补充你所需要的例子 😜。 组件可以包含其他对象和组件让我们回到我所说的关于布局的形式。 下是组件的完美示例。 响应式排版的付款表单 之前我提到过这段HTML: 1234567891011&lt;form class=&quot;form l-form&quot; action=&quot;#&quot;&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form__row&quot;&gt; &lt;div class=&quot;form__item l-form__item--large&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form__item l-form__item--small&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- ... --&gt;&lt;/form&gt; 我实际上省略了很多代码，使其在布局部分中看起来合理。 如果我们深入挖掘，你会看到有input和.o-button对象。 123456789101112131415&lt;form class=&quot;c-form l-form&quot; action=&quot;#&quot;&gt; &lt;div class=&quot;c-form__row&quot;&gt; &lt;div class=&quot;c-form__item l-form__item&quot;&gt; &lt;label for=&quot;fname&quot;&gt; &lt;span&gt;First Name&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;fname&quot; name=&quot;fname&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;!-- ... the email input item --&gt; &lt;/div&gt; &lt;!-- ... other form_rows --&gt; &lt;div class=&quot;c-form__row&quot;&gt; &lt;button class=&quot;o-button c-form__button&quot;&gt;Buy Mastering Responsive Typography!&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 看看.c-form现在是否包含其他对象？ :) 组件是上下文感知的（一般而言）组件是相当大的，所以您需要特别注意将它们放置在不同的地方。 例如，这个.c-form组件可以放在整个宽度栏中或侧边栏中。 以下是放在侧栏上下文中的表单： 表单组件放在侧边栏上 马上就可以看到三件事情改变了： 标签被隐藏 input和o-button对象的布局变为百分百宽度 文本的Font-size和line-height在按钮对象上变小。 此更改表单的HTML可能是： 1234567891011121314&lt;form class=&quot;c-form--sidebar l-form--sidebar&quot; action=&quot;#&quot;&gt; &lt;div class=&quot;c-form__row&quot;&gt; &lt;div class=&quot;c-form__item l-form__item&quot;&gt; &lt;label for=&quot;fname&quot;&gt; &lt;span&gt;First Name&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;fname&quot; name=&quot;fname&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ... the email input row --&gt; &lt;div class=&quot;c-form__row&quot;&gt; &lt;button class=&quot;o-button c-form__button&quot;&gt;Buy Mastering Responsive Typography!&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 并且各自的（S）CSS更改是： 123456789101112131415.l-from--sidebar &#123; .l-form__item &#123; /* change to full width style */&#125;&#125;.c-form--sidebar &#123; label &#123; // http://snook.ca/archives/html_and_css/hiding-content-for-accessibility @include is-invisible; &#125; .c__button &#123; font-size: 16px; line-height: 1.25; &#125;&#125; 还有一件事。 注意到了我混合了一个对象和组件类在.c-form__button里么？ 这被称为BEM混合，它允许我使用组件的类来创建一个对象，而不影响原始按钮。 组件的总结组件（.c-）是您可以在整个站点中使用的更大的构建块。组件有着以下属性： 组件使用’.c-‘前缀 组件可以包含其他对象和组件。 组件是上下文感知的 接下来我们来说下一个命名空间。 “.js”——JavaScript的钩子Javascript 钩子（.js）表示对象/组件是否需要JavaScript。 举个栗子，我之前提到的倒计时器 123&lt;div class=&quot;o-countdown jsCountdown&quot;&gt; &lt;!-- ... --&gt;&lt;/div&gt; 使用JavaScript命名空间的好处是可以将JS功能与样式分开，这使得它们更易于维护。 例如，您刚刚看到.jsCountdown类就可以立即知道，.o-countdown需要JavaScript才能正常工作。 如果将来有需要将o-countdown更改为c-countdown，我也不必担心破坏任何JS功能。 JavaScript钩子很简单，所以让我们继续吧。 “.is-/.has-” ——状态类状态类表示对象/组件的当前状态。当应用状态类时，您可以立即知道对象/组件是否具有下拉（.has-dropdown）或当前处于打开状态（.is-open）。 这些可爱的课程来自SMACSS（如果你想知道的话）。 当您在CSS中设计状态类时，建议您尽可能保持样式接近所讨论的对象/组件。 例如： 1234// Sass.object &#123; &amp;.is-animating &#123; /* styles */&#125;&#125; 如果您不用Sass,你可以用这种方式来书写CSS： 1`.object.is-animating &#123; /* styles */ &#125;` 由于Jonathan早已介绍了这点，所以你可能会了解状态类。 所以我不再多说:) 让我们继续。 “.t”或“.s”——排版类(Typography)在排版中最好的做法是在网页上只使用少数样式（大小，字体等）。 现在，你可能会在标题&lt;h1&gt;-&lt;h6&gt;中写出这样的排版风格： 123456h1 &#123; /* styles */ &#125;h2 &#123; /* styles */ &#125;h3 &#123; /* styles */ &#125;h4 &#123; /* styles */ &#125;h5 &#123; /* styles */ &#125;h6 &#123; /* styles */ &#125; 如果您的网站很简单，那么这是一个很好的开始，并且不需要为多个对象/组件使用相同的标题样式。 但是举个栗子哈，如果你有一个带链接的导航样式和你的h5样式一致怎么办？ 你会这样做吗？ 123456&lt;!-- 哎呀，千万别这么做！--&gt;&lt;nav class=&quot;c-nav&quot;&gt; &lt;h5&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/h5&gt; &lt;h5&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/h5&gt; &lt;h5&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/h5&gt;&lt;/nav&gt; 显然咱不能这么干。那么更好的方式就是改变我们的CSS样式。所以或许这么改？ 1234nav a &#123; font-size: 14px; line-height: 1.25;&#125; 虽然改动CSS的版本稍微好一点，但是在排版风格方面，解决问题方式定不会只有一种。你能找出30种不同的组合也只是一个时间的问题。 下面是一个潜在的解决方案。 你可以分别创建.h1到.h6的样式来应用到你的HTML，而不是利用-样式，像这样： 12345&lt;nav class=&quot;c-nav&quot;&gt; &lt;a class=&quot;h5&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;a class=&quot;h5&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;a class=&quot;h5&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/nav&gt; 我喜欢这种解决方案的简单性，其中有一个排版真理的来源。 您只需访问一个_typography.scss文件即可在网站上显示不同排版大小的数量。 现在，虽然.h1 - .h6类的解决方案很棒，但我强烈建议不要用.h1 - .h6为你的类，只是因为它们被隐含地绑在&lt;h1&gt;-&lt;h6&gt;对象上。 如果你有一个&lt;h2&gt;元素，但决定用.h3来写样式它会发生什么？ 接管你的代码库的另一个开发人员可能会遇到一个最初的不和他们去“为什么is.h3 _和_&lt;h2&gt; _写在一起了？ 所以，不是写.h1到.h6的样式，我给排版类不同的前缀，这取决于它们是比我的基本font-size大或更小。 以下是一个例子： .t1 - 最大的字体大小。 .t2 - 第二大字体大小。 .t3 - 第三大字体大小。 .s1 - 第一字体大小较小的基本字体大小。 .s2 - 第二字体大小较小的基本字体大小。 … 这五个class通常是我每个项目所需的一切（到目前为止）。 这样一个惯例的好处就是能够一目了然地告诉元素的大小。 在下面的例子中，我确定这个链接的尺寸小于我的基本字体大小。 1`&lt;nav&gt;&lt;a class=&quot;s1&quot; href=&quot;#&quot; &gt;Link&lt;/a&gt;&lt;/nav&gt;` 现在，如果您无法控制HTML，但想要控制排版类的大小呢？ 对于这种情况，我建议您创建和使用mixins，如下所示： 123456789@mixin s1 &#123; font-size: 14px; line-height: 1.25&#125;h1,nav a &#123; @include s1;&#125; 在我们进入下个话题的最后一件事。 要特别注意这一点。 排版类是对象的_子集。您应该像排列对象那样将相同的一套规则应用于排版类_。 这意味着你不应该在排版类中添加margin或padding。而这些margin或padding应该直接添加到组件。（阅读Harry的在大型应用上管理排版了解为什么我推荐这个）。 让我们继续。 “.u-” ——实用类(Utility)实用类是用来表现样式的一个非常好的辅助类。它们做得很好，并且其优先级高超过了其他样式。 因此，它们通常只包含一个属性，并且包含!important声明。 例子如下： 123456789101112131415.u-text-left &#123; text-align: left !important; &#125;.u-text-center &#123; text-align: center !important; &#125;.u-text-right &#123; text-align: right !important; &#125;.u-hide-st-med &#123; @media (man-width: 599px) &#123; display: none !important; &#125;&#125;.u-hide-bp-med &#123; @media (min-width: 600px) &#123; display: none !important; &#125;&#125; 我刚才在这里说的几乎是我用于实用类的一切。 我从来没有发现有了这些类还有做不好的事。 唷。闲话不说，咱回到工作/玩耍/学习或任何你正在做的事情，所以让我们来回顾一下。 结语在本文中，我向您展示了如何使用命名空间填补BEM的遗憾。通过包含命名空间，我终于实现了一个好的架构中寻找的所有四个标准： 类必须尽量少地添加避免HTML膨胀。 我必须立即知道组件是否使用JavaScript。 我必须立即知道是否可以安全地编辑一个类而不会影响其他任何其他CSS。 我必须立即知道每个class是适合于什么，以防止大脑过载。 总之，我总共使用了七个不同的命名空间。 他们是： .l-: 布局(layouts) .o-: 对象(objects) .c-: 组件(components) .js: js的钩子(JavaScript hooks) .is-|.has-: 状态类(state classes) .t1|.s1: 排版大小(typography sizes) .u-: 实用类(utility classes) 每个命名空间都有一个功能，可以在整个事物的宏伟计划中进行，进一步加强了样式表中的层次结构。 接下来，我将与大家分享一下如何打破这些我刚才设置的规则（“嗯，再次?!你真的喜欢打破规则吗？”😅）以及我如何组织我的CSS文件。 现在，我好奇的听到你的想法。你觉得我使用的命名空间如何？我的“违背专家命名空间”的使用.o-和.c-对你有帮助/有用吗？还是更让你迷糊呢？我很想听到你在下面的评论中的想法:) （如果你喜欢这篇文章，分享出来 — Namespaces.&amp;url=https://zellwk.com/blog/css-architecture-2/&amp;hashtags=). 我会很感激你的🤗)","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Node v8.0.0 正式发布，一波主要新特性 | Node.js","date":"2017-06-04T11:02:16.000Z","path":"2017/06/04/Node-v8-0-0-正式发布，一波主要新特性-Node-js/","text":"本翻译同时发布在平台众成翻译附上原文链接 接下来发布的这个版本的node.js会带来一系列重大的改变和影响,有太多要点以至于我们无法在这样一篇文章中充分覆盖其特性。但这篇文章包含了其最大改变和特性的总结。 npm version 5.0.0npm的公司近期宣布发布了5.0.0版本客户端我们也非常开心能够在node.js 8.0.0版本中用到这个新版本. V8 5.8node.js 8.0.0版本附带了v8引擎的5.8版本的，此版本对JavaScript运行时性能提升了很多，也包括在性能改进和面对开发者人员API的主要提升。对于node.js开发者来说最重大的意义莫过于v8 5.8版本保证了在今后的5.9或者即将来临的6.0版本的ABI兼容性，这也将确保Node.js原生插件系统的稳定性。在Node.js 8的有生之年，我们计划转移到v8的5.9版本或者更有甚者到6.0版本。 V8 5.8引擎同时有助于建立一个新TurboFan + Ignition编译管道的过渡，其承诺给所有node.js应用提供重大的新表现优化。虽然TurboFan and Ignition在V8先前的版本也已经存在，但它还是会在V8 5.9的第一时间默认使用。这种新的编译管道代表了如此重大的一个变化以至于Node.js核心技术委员会（CTC）选择推迟了原计划定于四月的Node.js 8版本的发布，只是为了更好地适应它。 Node.js API (N-API)对于使用或者开发原生插件的Node.js开发者来说，这个新的实验性的Node.js API（N-API）对于现有的Native Abstractions for Node.js (nan)是一个重大的进步。它将会允许原生插件在系统上无需重复编译并且可跨多个不同版本的Node.js使用。 通过提供一个新的虚拟机不可知应用程序接口（ABI），原生插件不仅可以在多个版本的V8 javaScript运行，也可以在微软的Chakra-Core运行将成为可能。 N-API在Node.js 8.0.0中还是实验阶段，所以我们应该期待正式的实施和API的重要改变。我们鼓励开发者们尽快开始使用API并且希望能够提供反馈，以确保新的API是满足这个生态圈系统的需求。 async_hooks这个实验性的 async_hooks 模块（以前叫async_wrap）在8.0.0版本中获得重大升级。该诊断API允许开发人员使用监视Node.js事件循环的操作，通过其完整的生命周期跟踪异步请求和处理。该新模块完整的文档仍然不完整，用户在使用这个实验性的新模块时应格外小心。 WHATWG URL parser去年，围绕WHATWG URL Standard实施的实验性URLAPI已添加到Node.js 7.x中，自此一直处于积极的发展之中。我们很高兴地宣布，从8.0.0开始，新的URL实现现在是Node.js中完全支持的非实验API。 下面显示了一个示例用法，更多详细信息可在官方文档中看到。 123const URL = require(&apos;url&apos;).URL;const myUrl = new URL(&apos;/a/path&apos;, &apos;https://example.org/&apos;); 这个新的URL实现是最有意义的在于它与现代Web浏览器（如Chrome，Firefox，Edge和Safari）中的URL实现和API相匹配，允许使用URL在不同环境之间共享代码。 Buffer changes缓冲区的变化对Node.js中的BufferAPI进行了一些重要更改。最重要的是调用不推荐使用的 Buffer（num）构造函数（使用或不使用new关键字）将返回一个零值初始化的Buffer实例。 先前版本的Node.js将返回未初始化的内存，这可能包含潜在的敏感数据。 在Node.js 6.0.0中，一组新的 Buffer构造方法作为调用Buffer（num）构造函数的替代方法被引入，以解决一些安全性和可用性问题。 然而，现有的构造函数在Node.js生态系统中被广泛使用，使我们无法完全弃用或禁用它，而不会导致重大的破坏。 默认情况下没有零值初始化的Buffer（num）的新实例将对性能产生重大影响。 如果开发人员希望分配具有未初始化内存的Buffer实例，则应转移到新的Buffer.allocUnsafe（num）API。 Node.js 8中零值初始化和未初始化的“缓冲区”创建示例如下所示。 123456// 使用零值初始化Buffersconst safeBuffer1 = Buffer.alloc(10);const safeBuffer2 = new Buffer(10);// 未初始化Bufferconst unsafeBuffer = Buffer.allocUnsafe(10); 请注意，虽然目前没有从Node.js中删除Buffer（num）构造函数的计划，但是已经弃用对其的后续维护。 Pending Deprecations为了在开发时或CI测试环境中更容易地捕获应用程序中的Buffer（num），我们添加一个新的--pending-deprecation命令行标志和匹配的NODE_PENDING_DEPRECATION = 1环境变量，这会导致当使用Buffer（num）（和其他潜在的待弃用的方法）时Node.js发出DeprecationWarning的进程警告。 为了避免类似这种弃用影响到生产应用程序，默认情况下是停用它们的。 下面显示一个允许未决弃用的示例。 1234$ ./node --pending-deprecation&gt; Buffer(num)&lt;Buffer 00&gt;&gt; (node:2896) [DEP0005] DeprecationWarning: The Buffer() and new Buffer() constructors are not recommended for use due to security and usability concerns. Please use the new Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() construction methods instead. 提升对Promises的支持Node.js 8.0.0包含一个新的util.promisify（）API，它允许在一个返回Promise的函数中包装标准的Node.js回调样式API。 util.promisify（）的使用示例如下。 12345678const fs = require(&apos;fs&apos;);const util = require(&apos;util&apos;);const readfile = util.promisify(fs.readFile);readfile(&apos;/some/file&apos;) .then((data) =&gt; &#123; /** ... **/ &#125;) .catch((err) =&gt; &#123; /** ... **/ &#125;); Console 的改变通过Node.js中的console模块可以将console.log(), console.error()和其他方法将应用程序定向输出到stdout，stderr或者管道。 在以前，尝试将控制台输出写入到基础流时发生的错误从而导致Node.js应用程序崩溃。 从8.0.0开始，这样的错误将被忽略，从而使console.log（）和其他API更安全。 这将可能通过传递给Console构造函数的ignoreErrors配置来维护与错误相关的遗留行为。 静态错误码我们已经开始为Node.js生成的所有错误分配静态错误码的过程。 然后每个错误都需要一段时间才能被分配一个错误码码，在8.0.0之内已经更新了一些错误。 即使错误类型或消息发生变化，也保证这些错误码不会改变。 错误码以两种方式显示给用户：Codes are manifest to the user in two ways: Using the code property on Error object instances Printing the [ERR_CODE] in the stack trace of an Error 例如，调用assert（false）会生成以下的AssertionError： 123456789101112&gt; assert(false)AssertionError [ERR_ASSERTION]: false == true at repl:1:1 at ContextifyScript.Script.runInThisContext (vm.js:44:33) at REPLServer.defaultEval (repl.js:239:29) at bound (domain.js:301:14) at REPLServer.runBound [as eval] (domain.js:314:12) at REPLServer.onLine (repl.js:433:10) at emitOne (events.js:120:20) at REPLServer.emit (events.js:210:7) at REPLServer.Interface._onLine (readline.js:278:10) at REPLServer.Interface._line (readline.js:625:8) 通过引用Node.js文档，可以快速查询有关静态错误码的信息。 例如，查询有关“ERR_ASSERTION”错误码的信息的URL是https://nodejs.org/dist/latest-v7.x/docs/api/errors.html#ERR_ASSERTION. 重定向过程警告使用--redirect-warnings = {file}命令行参数或匹配NODE_REDIRECT_WARNINGS = {file}环境变量可以处理诸如deprecations之类的警告，可以将其重定向到一个文件。 默认情况下，不会将警告打印到stderr，而是将警告写入指定的文件，从而我们将更清晰地分析应用程序的主要输出。 Stream API 改进对于Stream API的用户，已添加了用于销毁和完成Stream实例的新标准机制。 每个Stream实例现在将继承一个destroy()方法，通过提供_destroy()方法的自定义实现，可以定制和扩展它们的实现。 Debugger 的改变Node.js 8正在删除遗留的命令行调试器。 作为命令行替换，node-inspect已经直接集成到Node.js运行时。 此外，以前在Node.js 6中的一项实验功能——V8 Inspector调试器，正在升级为完全支持的功能。 实验性的检查器 JavaScript API已经引入了用于Inspector协议的新的实验性JavaScript API，使开发人员能够利用调试协议来检查运行的Node.js进程的新方法。 123456789101112const inspector = require(&apos;inspector&apos;);const session = new inspector.Session();session.connect();// Listen for inspector eventssession.on(&apos;inspectorNotification&apos;, (message) =&gt; &#123; /** ... **/ &#125;);// Send messages to the inspectorsession.post(message);session.disconnect(); 请注意，检查器API是实验性的，可能会发生大改变。 长期支持Node.js 8是下一个进入长期支持（LTS）的发行版。 这将于2017年10月发生。 一旦Node.js 8转换到LTS，它的代号将变为Carbon。 请注意，在引用Node.js发行版本时，我们已经在Node.js 8中删除了“v”。 以前的版本通常被称为v0.10，v0.12，v4，v6等。为了避免与JavaScript引擎V8混淆，我们删除了“v”并将其称为Node.js 8。 明显变化 异步钩子Async Hooks 在内核中已实现async_hooks模块[4a7233c178]#12892. 缓冲区Buffer 在使用new Buffer(num)或Buffer(num)时,带上--pending-deprecation将导致Node.js发出一个废弃警告。[d2d32ea5a2]#11968. new Buffer(num) and Buffer(num) 会生成零值初始化新的Buffer实例[7eb1b4658e]#12141. 现在许多Buffer方法接受Uint8Array作为输入[beca3244e2]#10236. Child Process Argument和kill信号验证得到改善[97a77288ce]#12348,[d75fdd96aa]#10423. Child Process方法接受Uint8Array作为输入[627ecee9ed]#10653. Console 使用console方法时，错误事件发送现在受到了抑制。[f18e08d820]#9744. Dependencies npm客户端已经升级到5.0.0[3c3b36af0f]#12936. V8引擎已经升级到5.8版本并具有向前的ABI兼容性一直到6.0版本[60d1aac8d2]#12784. Domains 原生Promise实例现在是域感知的[84dabe8373]#12489. Errors 我们已经开始为Node.js生成的错误分配静态错误代码。这是通过多次提交完成的，目前仍在进行中。 File System 实用程序类fs.SyncWriteStream已被弃用[7a55e34ef4]#10467. 已弃用的fs.read()字符串接口已被删除[3c2a9361ff]#9683. HTTP 改进对用户使用代理的支持[90403dd1d0]#11567. 溢出的Cookie headers会被连接成一个字符[d3480776c7]#11259. 其httpResponse.writeHeader()方法已被弃用[fb71ba4921]#11355. 用于访问HTTP头的新方法已添加到OutgoingMessage中。[3e6f1032a4]#10805. Lib 所有弃用消息已分配静态标识符[5de3cf099c]#10116. 遗留的linkedlist模块已被删除[84a23391f6]#12113. N-API 添加了对新的N-API API的实验性支持[56e881d0b0]#11975. Process 可以使用--redirect-warnings命令行参数将进程警告输出重定向到文件[03e89b3ff2]#10116. 过程警告现在可能包括额外的细节[dd20e68b0f]#12725. REPL REPL magic模式已被弃用REPL[3f27f02da0]#11599.","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"电钢小白——《river flows in you》","date":"2017-04-05T13:38:16.000Z","path":"2017/04/05/电钢小白——《river flows in you》/","text":"不专业的程序猿的日常 《river flows in you》","tags":[{"name":"colorful life","slug":"colorful-life","permalink":"http://yoursite.com/tags/colorful-life/"}]},{"title":"关于一些模块化的东西","date":"2017-04-05T12:34:48.000Z","path":"2017/04/05/modules/","text":"整理思路：附有一些资料&amp;链接的脑图（ps:一篇写了一半的文章） 一、CMD规范 Common Module Define 公共模块声明 服务器端模块的规范 一个文件就是一个模块 至少有的特点： 序列单独的模块 模块内部定义的变量不会暴露给外面 都是懒加载 模块定义： 1define(factory); 1.define里接受一个参数，即factory模块2.这个factory可以是一个函数或者其他的合法值3.如果factory是一个函数，那么这个函数只要写了参数，其前三个参数必然是“require”、“exports”和“module”以及这个秩序4.如果factory不是一个函数，那么这个模块输出的则是这个对象。 require functionrequire是一个函数 1.其接受一个模块标识 2.它返回的是所引模块输出的API 3.如果所引模块不能正常返回，那么require会返回null require.async是一个函数 1.其接受一个列表的模块还有一个回调函数 2.回调函数会将引入模块的输出作为参数使用，参数顺序依照引入列表顺序 3.如果请求模块不能正常返回，那么回调也相应为NULL AMD规范 (Async Module Define)异步模块声明 浏览器端 1define(id?,dependencies?,factory) 前端模块化价值 模块化：遵守commonjs规范 先是创建了公共工具，占用全局变量名，使后面自定义其他工具函数产生命名冲突。解决办法是引入命名空间，问题是为了调用一个方法名字太长 解决了不同文件之间的分工和调用问题 组件化 “资源高内聚”—— 组件资源内部高内聚，组件资源由自身加载控制“作用域独立”—— 内部结构密封，不与全局或其他组件产生影响“自定义标签”—— 定义组件的使用方式“可相互组合”—— 组件正在强大的地方，组件间组装整合“接口规范化”—— 组件接口有统一规范，或者是生命周期的管理 componentWillReceiveProps() — 已插入的组件收到新的props时调用","tags":[{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"}]},{"title":"js检测浏览器基本属性","date":"2016-11-03T10:59:19.000Z","path":"2016/11/03/js检测浏览器基本属性/","text":"这是一篇用来讲解如何玩浏览器的各项属于以及这些基本属性助力于我们兼容性的文章 detector 利用这个工具我们大致可以知道当前使用端的浏览器基本信息，和设备基本情况，即浏览器名字版本内核等、设备名字操作系统版本等。 modernizr 想安利一下这个工具，特别好用。它是用来检测一些h5 or CSS3的属性支持情况的，在官网可以自定义选择需要检测的属性，使用方法也很简单，最基础的使用就是，引用文件后，直接在脚本里： 12modernizr.attr&lt;!--返回一个true/false--&gt; 即可判断浏览器是否支持其属性。同时这个文件引用后在html标签里会生成一系列的class例如“js flash no-canvas”的字段，其表示该环境支持js flash，但不支持canvas，可以利用这个class在写stylesheet的时候给不支持的标签写上对应的样式，例如 1234.no-canvas&#123; display:none;&#125; 浏览器缩放判断 思路：（分三类） chrome类，即webkit/blink内核。 IE类 其他类型浏览器 码上看 1234567891011121314151617181920212223242526//页面的缩放情况判断function scaleJudge()&#123; var scale = 0, Screen = window.screen, ua = navigator.userAgent.toLowerCase(); //chrome、blink if (!!window.devicePixlRadio) &#123; scale = window.devicePixlRadio; //IE下，IE11木有msie &#125;else if (ua.indexOf('msie')&gt;-1 || ua.indexOf(\"rv:11\")&gt;-1 ) &#123; if (Screen.deviceXDPI &amp;&amp; Screen.logicalXDPI) &#123; scale = Screen.deviceXDPI/Screen.logicalXDPI; &#125;; //其他的一些 &#125;else if (!!window.outerWidth &amp;&amp; !!window.innerWidth)&#123; scale = window.outerWidth/window.innerWidth; &#125; if (scale) &#123; scale = Math.round(scale * 100); &#125;; // 某些诡异时的outerWidth和innerWidth不相等(比如火狐) if( scale === 99 || scale === 101 )&#123; scale = 100; &#125; &#125; 判断js可用 way 1: 在dom中添加js不可用的提示信息，再在脚本里写因此这一节点。 js正常加载时,是会顺利隐藏它的。否则会出现不可用的提示信息。 弊端：正常加载情况下页面会闪一下。 way 2（better）: 在dom中直接添加如下信息： 12345&lt;script type=\"text/javascript\"&gt; haosou.docWrite('&lt;!--');&lt;/script&gt;……只有js不能用啦，我才会展示出来&lt;!-- 不要删我 --!&gt; “haosou.docWrite”是在head区域的一个外链js中，重写的document.write的方法，正常加载时候效果相当于把页面里的快给注释掉了。只有当js不可用时后面的内容才会出现。这样做的好处是页面在渲染的时候就会控制好显隐，减少回流（不会出现闪一下的情况）。 判断flash可用 直接上码 12345678910111213141516171819202122232425262728// 是否支持flashfunction flashJudge()&#123; var flag = false; //ie下 if(window.ActiveXObject)&#123; try&#123; var swf = new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\"); if(swf)&#123; flag = true; var flashVersion = swf.GetVariable(\"$version\").split(' ')[1]; // console.log(flashVersion); &#125; &#125;catch(e)&#123; &#125; //非IE &#125;else&#123; try&#123; var swf = navigator.plugins['Shockwave Flash']; if(swf)&#123; flag = true; var flashVersion = swf.description.split(' ')[2]; &#125; &#125;catch(e)&#123; &#125; &#125; // console.log(flashVersion);&#125;","tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://yoursite.com/tags/浏览器兼容/"}]},{"title":"浏览器信息初步搜集","date":"2016-10-12T12:54:55.000Z","path":"2016/10/12/浏览器信息初步搜集/","text":"浏览器差异 因为浏览器众多，内核、版本、渲染机制以用户习惯又不尽相同，因此我们对其的调研是很有必要的。 我们根据各个浏览器占额从大到小来分析不同的浏览器 ￼ 图示：浏览器类型2016年占额 数据From net market share https://www.netmarketshare.com/browser-market-share.aspx?qprid=0&amp;qpcustomd=0&amp;qptimeframe=Y ￼ 图示：各浏览器版本2016年占额 数据From net market share https://www.netmarketshare.com/browser-market-share.aspx?qprid=2&amp;qpcustomd=0&amp;qptimeframe=Y ￼ 图示：国内浏览器2016年市场占额 数据From 百度统计http://tongji.baidu.cn/data/browser 一. Chrome浏览器 webkit版本 v8引擎版本 支持系统 稳定版本：Windows, OS X, Linux 最新53.0.2785.143(9月) Chrome 50开始结束了对Windows XP系统的支持 编程语言：C++、汇编语言、Javascript 多进程架构 v8引擎（JavaScript）：利用内置独立的JavaScript虚拟机“V8”来提高运行Java收到速度。 传统的Javascript是动态语言，又可称之为Prototype-based Language，JavaScript继承方法是使用prototype，通过指定prototype属性，便可以指定要继承的目标。属性可以在运行时添加到或从对象中删除，引擎会为运行中的对象创建一个属性字典，新的属性都要通过字典查找属性在内存中的位置。V8为object新增属性的时候，就以上次的hidden class为父类别，创建新属性的hidden class的子类别，如此一来属性访问不再需要动态字典查找了。 为了缩短由垃圾收集造成的停顿，V8使用stop-the-world, generational, accurate的垃圾收集器。在执行回收之时会暂时中断程序的执行，而且只处理对象堆栈。还会收集内存内所有对象的指针，可以避免内存溢出的情况。V8汇编器是基于Strongtalk汇编器。 webkit（HTML排版引擎）：webkit简易小巧，并能有效率地运用内存，但从28.0（2013.7.9）开始，其以webkit引擎为基础，为chrome开发全新的 blink引擎，比现行webkit引擎更简化程序源代码，并对多进程有更好的支持。Chrome长期在The HTML5 Test的测试结果中居于高位。 Skia（图像处理引擎）： 全面支持SVG, Canvas的需求/较小的资源占用/跨平台 sandbox 技术： 尽可能利用操作系统提供的安全性能 提供尽可能少的权限 目标： 保护用户的系统不被网页上的恶性软件侵入 保护用户系统的输入事件不被监视 保护用户系系统中的文件不被偷取 错误帮助相关： 1. 针对浏览器错误提供建议： 出现无法解析网址或未能成功连接的状况时，“Google Chrome”会尝试判断想要前往的网页，并提供建议。 2. 拓展程序 二. Microsoft Internet Explorer (IE) Internet Explorer提供了最宽广的网页浏览和创建在操作系统里的一些特性，例如：为Microsoft Update而设计。在最著盛名的浏览器大战中，微软用提供了最具改革新的特性替换了Netscape。 稳定版本： Windows：11.0.34（11.51.14393.0）（8月） Mac：5.2.3（13年前） Unix：5.01 SP1（15年前） 编程语言：C++ 操作系统：Windows、Mac OS X、Solaris、HP-UX Chakra（JavaScript引擎）：IE9-IE11使用的。其特色是，它在一个独立的CPU核心上即时编译脚本，与浏览器并行。该引擎也能够访问电脑的图形处理器(GPU)，特别是对 3D 图形和视频的情况。 ￼ Trident（HTML排版引擎）：几乎完整支持HTML 4.01，CSS Level 1，XML 1.0和DOM Level 1，只是有一些排版错误。它亦部分支持CSS Level 2和DOM Level 2。它自带的XML解释器支持XHTML，但是微软从IE 5.0以后取消了这一支持，使它变得难以访问。如其它浏览器一样，当MIME类型标识为text/html，它能解释为XHTML。当MIME类型标识为application/xml和text/xml时，它也能解释把XHTML解释为XML，但需要一个小的XSLT度量来重新启用XML对XHTML的支持。当把它定义为偏好类型如application/xhtml+xml时，它假装不理解XHTML，相反把它当成一种不了解的供下载的文件类型来对待。 Internet Explorer依靠DOCTYPE判断一个网页应该按老版本渲染还是按W3C标准渲染（在打印中，Internet Explorer总使用W3C标准。）。根据MSXML的版本不同，它可以完全支持XSLT 1.0或1998年12月的XSL草案。Internet Explorer有一个自己的ECMAScript变体，名为JScript。 最新版其对HTML5部分支持，但是相比于其他浏览器支持度仍偏低。 专利的延展组件 Internet Explorer引进了一系列专利的网页标准延伸，包括HTML，CSS和DOM。这令到一些网站只可被Internet Explorer正常显示。 错误帮助相关： 图像标准： 由于IE对PNG图像Alpha 通道的不支持导致了PNG图像格式在网上使用率的减少。虽然只是一个可选的特性，阿尔法通道却是把PNG与其他像GIF或者JPEG这样的格式相区别的一个特色。 在Internet浏览器中，透明的部分的形象将被显示作为灰色，白或者其他颜色。 不像其他浏览器，Internet Explorer不允许MIME在Content-Type信头段中定义MIME类型。比如一个纯文本格式的档内包含了HTML样式的标记就会被识别为HTML文档，而不是纯文本文档。但在这种情况下，可以通过手动修改注册表的方式强行改变运行行为。 Internet Explorer对多语言文本支持Unicode标准，因此其理论上有能力显示任何已经安装字体的字符。但实际上，Internet Explorer不会对混和Unicode文本自动选择字体。这种情况下字符可能会以一个空格结束或显示为问号。网页设计者必须猜测在用户电脑上显示哪种字体最为合适，如果需要改变就需要对每个Unicode块进行手动改变。而对其他浏览器却可以自动完成这个操作。 ￼IE10 Quirks 是为了在那些针对 HTML5 设计，但是又没有添加 doctype的页面而存在的。除了在dev tools里面查看，我们还能在document.compatMode 中获取文档模式，产生的两个属性值‘BackCompat’-&gt;Quirks Mode/‘CSS1Compat’-&gt;Standards Mode。对于这个模式状态我们可以查看一下。 （一）IE7 首次开始完整支持W3C标准JScript engine （二）IE8 JScript engine （三）IE9 从IE9开始已经完全符合W3C标准 由于更换的JavaScript引擎导致与之前引擎差异： 枚举顺序不同 数学精度程度不同 IE9 在不同文档模式下支持不同的 ECMAScript 标准和扩展名。 三. safari 稳定版本： 10.0 (on macOS 10.12) (2016.9) 编程语言：C++ Objective-C 操作系统：macOS IOS Nitro(after 4) JavaScriptcore（JavaScript引擎）： webkit（HTML排版引擎）： 错误帮助相关： 未能采用现代标准： html5特性支持较少。 四. firefox 稳定版本： Standard 49.0.1 (2016.9) 编程语言：C++, JavaScript, C, Rust, CSS, XUL, XBL 操作系统：Windows, macOS, Linux,Android, iOS,(Unofficial ports to BSDs, Solaris,OpenSolaris, illumos) JavaScript引擎: spiderMonkey：第一款JavaScript引擎,用于Mozilla Firefox 1.0～3.0版本。 Rhino：由Mozilla基金会管理，开放源代码，完全以Java编写。 TraceMonkey：基于实时编译的引擎，其中部份代码取自Tamarin引擎，用于Mozilla Firefox 3.5～3.6版本。 JaegerMonkey：德文Jäger原意为猎人，结合追踪和组合码技术大幅提高性能，部分技术借凿了V8、 JavaScriptCore、WebKit：用于Mozilla Firefox 4.0以上版本。 IonMonkey：可以对JavaScript编译后的结果进行优化，用于Mozilla Firefox 18.0以上版本。 OdinMonkey：可以对asm.js进行优化，用于Mozilla Firefox 22.0以上版本。 Gecko / WebKit-&gt;’only for iOS’（HTML排版引擎）： 代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 错误帮助相关： 自动拦截的问题，可检测 插件兼容 js在IE与FF的不兼容问题 五. opera 稳定版本： 40.0.2308.81 (2016.10) 编程语言：C++ 操作系统：Windows、OS X、Linux JavaScript引擎： Carakan：由Opera软件公司编写，自Opera10.50版本开始使用。 v8： 15版本至今 blink（2013）（HTML排版引擎）： 特性： 符合标准化 错误帮助相关 兼容性低 内存占有高 六、关于浏览器渲染repaint、reflow ￼ repaint比reflow明显更快。 在IE下也一样，但是在IE下两个都慢，所以我们说reflow比repaint还要缓慢。 呈现主流程 ￼ 图：Webkit主流程 ￼ 图：Geckoc呈现引擎主流程 这里有一篇文章详细介绍了浏览器的工作原理 OS ￼图示：各操作系统2016年占额 数据From net market share https://www.netmarketshare.com/operating-system-market-share.aspx?qprid=10&amp;qpcustomd=0&amp;qptimeframe=Y 通过图可以看出使用最多的操作系统是Windows，然后是mac OS,Linux。Mac OS 和 Linux是很相似的，它们都起源于一个简单但是强大并且更安全的操作系统–Unix。相比Mac OS更加专权，它是运行与它专有的硬件上的，这正是此提高了它的价格。Linux是开源免费的，所以这个社区用户集体可以检测它其中的各种漏洞。正因为Linux可以在我们大多使用的Windows电脑条件下运行，所以理所当然它成了用户赢家。但是你必须自己手动在你电脑上下载安装Linux。 Windows采用kernel。最复杂的系统，每一次迭代都会支持考虑更旧的版本。 维基百科上列有详细的各操作系统基本信息比对：各个OS的对比 通过各种资料调研，OS对浏览器内容的渲染影响不大，因为主要还是浏览器内核的渲染机制不同。但是不排除OS不同导致用户看到的场景不同可能。在搜集信息的时候，也看到因为OS导致的问题，大多体现在： 1.系统浏览器设置不同。 2.不同系统自带字体不同，在某些页面规定了本系统没有的字体时会用默认代替，导致与其他系统效果不同。 installed plugins &amp; fonts Doctor工具 采用detector工具1234567891011121314151617181920212223242526272829303132detector = &#123; device: &#123; name: &quot;iphone&quot;, version: -1, fullVersion: &quot;-1&quot;, [iphone]: -1 &#125;, os: &#123; name: &quot;ios&quot;, version: 6.1, fullVersion: &quot;6.1&quot;, [ios]: 6.1 &#125;, browser: &#123; name: &quot;chrome&quot;: version: 26.0, fullVersion: &quot;26.0.1410.50&quot;, mode: 26.0, fullMode: &quot;26.0.1410.50&quot;, compatible: false, [chrome]: 26.0 &#125;, engine: &#123; name: &quot;webkit&quot;, version: 536.26, fullVersion: &quot;536.26&quot;, mode: 523.26, fullMode: &quot;523.26&quot;, compatible: false, [webkit]: 536.26 &#125;&#125; 环境相关： 操作系统 detector.os 浏览器类型、版本 detector.browser.name detector.browser.version 是否兼容detector.browser.compatibledetector.engine.compatible 浏览器渲染引擎(×) engine 获取问题信息相关： 联系方式 问题展示 复现问题方式（手动填写） 出错时间、频次 具体错误相关： 出错地方（代码片段） 阻塞产生的问题","tags":[{"name":"for our project","slug":"for-our-project","permalink":"http://yoursite.com/tags/for-our-project/"}]},{"title":"跨域解决方式的归纳","date":"2016-10-09T12:24:39.000Z","path":"2016/10/09/跨域解决方式的归纳/","text":"一、单向跨域（用于获取数据） 1.1 jsonp 原理：script标签下的src没有同源限制(示例假设为so.com域名下)123456&lt;script&gt; function JSONP_example(param)&#123; console.log(param); &#125; &lt;/script&gt;&lt;script src=\"www.so.com/link.php\"&gt;&lt;/script&gt;1234#link.php&lt;?php&gt; echo 'JSONP_example([\"hello\",\"qianqian\"])';?&gt; 1.2 动态创建script标签 如上link.php改写为1234#link.php&lt;?php&gt; echo 'var varible = [\"hello\",\"qianqian\"]';?&gt;在本域的js里可以取到以上值，需判断script是否加载完成123456js.onload = js.onreadystatechange = function()&#123; if(!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')&#123; console.log(varible);//取出其他域的数据 js.onload = js.onreadystatechange = null; &#125;&#125; 1.3 图像ping 12345var img = new Image();img.onload = img.onerror = function()&#123; console.log('done')&#125;img.src = \"http://example.com/test?name='hello'\" 缺点 单向通信。无法访问服务器的相应文本。 只能发送get请求。 1.4 Access Control 此跨域方法目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的http请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access-Control-Allow-Origin的http响应头，它声明了可访问域的权限。 例如在so.com的域下对so发送一个getinfo.php。即加入如下响应头： 1header(\"Access-Control-Allow-Origin:http://www.so.com\"); //表示允许so.com的跨域文件请求 1.5 flash URLLoader flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域so.com请求域google.com上的数据，我们可以借助flash来发送HTTP请求。首先，修改域google.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把so.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就不可行了。 1.6 服务器代理 在数据提供方没有提供对JSONP协议或者 window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当so.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向 google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在so.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如so.com/proxy/, 然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性。 1.7 window.name window 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。 二、双向跨域(两个iframe或页面通信) 2.1 XDomain.js 快速使用： 在引用其他库之前先引用XDomain。当XDomain加载成功，xHook替换掉当前的window.XMLHttpRequest。如果其他库在这个原生window.XMLHttpRequest加载使用，那么XHook就无法获取这些请求。 1.在隶属域(slave domain)（http://xyz.example.com），创建一个 proxy.html 文件： 12&lt;!DOCTYPE HTML&gt;&lt;script src=&quot;//cdn.rawgit.com/jpillora/xdomain/0.7.4/dist/xdomain.min.js&quot; master=&quot;http://abc.example.com&quot;&gt;&lt;/script&gt; 2.在master domain (http://abc.example.com), 指向刚刚新建的 proxy.html 1&lt;script src=&quot;//cdn.rawgit.com/jpillora/xdomain/0.7.4/dist/xdomain.min.js&quot; slave=&quot;http://xyz.example.com/proxy.html&quot;&gt;&lt;/script&gt; 3.在master domain里向http://xyz.example.com里发的请求都可以生效了。 同时以下配置也可以使一个域的被多个域请求到：1master=&quot;http://abc.example.com/api/*&quot; 更多请查看 官方文档 2.2 location.hash 因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。下面举例说明： 假如父页面是so.com/a.html，其中嵌入的iframe页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。 1、a.html传送数据到b.html （1） a.html下修改iframe的src为google.com/b.html#data（2） b.html监听到url发生变化，触发相应操作 2、b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe （1） b.html下创建一个隐藏的iframe，此iframe的src是so.com域下的，并挂上要传送的hash数据，如src=”http://www.so.com/proxy.html#data&quot;（2） proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）（3） a.html监听到url发生变化，触发相应操作 b.html页面的关键代码如下123456789try &#123; parent.location.hash = &apos;data&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &quot;http://www.so.com/proxy.html#data&quot;; document.body.appendChild(ifrproxy); &#125; proxy.html页面的关键代码如下12//因为parent.parent（即so.com/a.html）和so.com/proxy.html属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 2.3 h5 postmessage 高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如so.com域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信 A页面通过postMessage方法发送消息：12345window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &quot;http://www.google.com&quot;; ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin); &#125;; postMessage的使用方法：1otherWindow.postMessage(message, targetOrigin); otherWindow: 指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口 message: 是要发送的消息，类型为 String、Object (IE8、9 不支持) targetOrigin: 是限定消息接收范围，不限制请使用 ‘*’ B页面通过message事件监听并接受消息:1234567891011121314var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==&quot;http://www.so.com&quot;)&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != &apos;undefined&apos;) &#123; window.addEventListener(&apos;message&apos;, onmessage, false); &#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123; //for ie window.attachEvent(&apos;onmessage&apos;, onmessage); &#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。 2.4 document.domain 同源策略认为域和子域是属于不同的域，因此也会存在跨域问题。比如wan.360.cn与360.cn是不同的域，我们不能在360.cn里调用wan.360.cn中定义的js方法，但是如果我们通过document.domain来设置成相同的，浏览器就会认为它们是在一个域下，就可以相互获取数据以及操作dom了。 三、小结 针对不同的情况，使用的解决办法不一样。但是比较常用的是jsonp(单向获取数据)，location.hash(双向通信)。当然对于引用库来说也是很便利的，不过在使用的时候了解其原理也很重要。","tags":[{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"}]},{"title":"source map","date":"2016-10-09T08:27:25.000Z","path":"2016/10/09/source-map/","text":"source map 使用场景 现在前端早已不是当年那个单纯的前端，我们想着各种方法来优化我们的代码，利用less、采用各种模板框架，然后使用编译工具、任务流来自动生成我们的产出，当然这个“产出”已经和我们开发环境写的码不一样了，最明显的就是一个代码压缩。几万行的代码压缩后可能就只有三四行，这很大程度减小了文件体积，但是却对debug造成了很大的干扰，如果出现问题，提示报错在第一行，那么第一行这上万的代码怎么找出那个出错地方？source Map就因此出现了，它是一个信息文件，里面储存着位置信息。有了它，出错的时候，出错工具直接显示原有代码而非转换后的代码。 启用方法在转换的代码尾部，加如下代码 1//@ sourceMappingURL=/path/to/file.js.map map可以为本地的，也可以为网络上的。 其实阮一峰大大的文章写得更详细，查看更多","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"}]},{"title":"css中有意思的黑魔法","date":"2016-09-12T12:10:30.000Z","path":"2016/09/12/css中有意思的黑魔法/","text":"1.Dirty Tricks From The Dark Corners Of Front-End 1.1 table hover十字架特效 1.2 图片的适应与破碎 1.3 “:empty”的使用 1.4 响应式布局 1.4.1 px、em、rem 1.4.2 vh&amp;vw / vmin&amp;vmax 1.4.3 calc() 2.日常遇到的一些点 2.1 浏览器缩放引发的问题 2.2 文字超出点点点效果实现 2.3 ie7 relative穿透 2.4 推荐实用小工具 一、 Dirty Tricks From The Dark Corners Of Front-End(分享后感想) 原演讲PPT地址dirty-tricks-from-the-dark-corners-of-front-end 本章只选取了部分作分析分享，有兴趣的童鞋可以自己去看看全部哒。 1.table hover十字架特效 想象一下，在我们工作中如果遇到需要这种情况，可能第一反应都是：横栏的效果是直接在tr上加特效“tr:hover”就行了，可是竖栏的效果呢？像我这样对css玩得不太溜的话可能第一反应是利用js控制选择元素，然后对应那一列的td都给加上背景。 当然在这里我们不用那种方式实现，采用css的伪元素实现。思路如下： ① 在hover的对应td后添加一个伪元素② 将它的宽设置和td一样③ 将这个伪元素的高度可以设大（表格高度不确定的情况），添加背景颜色④ 在table上设置overflow：hidden就OK啦 好啦，示例放上codepen链接：table hover十字架特效 注：css3的gradient也能实现相关学习文档： css3-gradient 2.图片的适应与破碎 对于图片显示，存在的问题的也比较多，比如尺寸大小适应问题，或者是图片失效了，哦多kei (1)对于尺寸自动适应问题 需求：我们已经创建和了一个完美的格子（或者正方形圆形之类的），场景就是我们的头像，但是当客户上传的图片尺寸不正确的时候，图片会遭受一定的变形。我们应该想些什么办法来处理这个问题呢？ 将图片变成一个正方形，我们可以加上一些基本样式 12345img&#123; width:100px; height:100px; border:1px solid;&#125; 但是这样做的话，图片的尺寸不合可能导致效果图显示不全或变形，我们能联想到在background背景图可以设置cover什么的各样，那么对于img标签的话，我们可以使用css3的一个新属性 object-fit （虽然宝宝并没用过，但是看到之后觉得很不错呀） object-fit:fill 想尽办法让自己将充满整个容器（此值为boject-fit的默认值）contain 保持长宽比例填充元素内容容器cover 保持长宽比例填充元素内容容器，就是一定要让容器变满none 替换元素内容不调整大小以适应内部元素的容器，内容完全忽略设置在元素上的任何高度和权重，并且仍在元素尺寸内显示。scalce-down 当内容大小设置了non或contain，将导致具体对象变得更小。 ps:此属性主要适用于替换元素（不限于img），也就是说还有video、object、input、svg、svg:image和svg:video等。object-fit与object-position一起使用更加666，后者属性决定了这个盒子里替换元素的对齐方式。可以在《CSS3 Object-fit和Object-position》一文中了解更多。 (2)图片加载不成功的时候，我们应该都会看到以下图片： 这样比较影响页面的美观，我们有其他什么方式可以设置这个加载失败的样式么？同样又通过伪元素。那么问题来了：img是 可替换元素，是不能应用伪元素呀？通过黑魔法的学习发现虽然img正常加载图片的时候不能应用伪元素，但是在图片加载失败的情况下，是可以使用的。 见小示例： 破碎图片的处理 3.”:empty”的使用 大家对alert一定不陌生，尤其是我们想要给它自定义样式，变得特别一点。这个时候的alert一般都不是系统的alert了，而是我们自己写的一个模板，一般通过display：none/block 来控制其显示与否，可是当这个alert模板里面没东西的时候，我们怎么能保证它确实是hidden的呢？ empty可以帮我们解决这个问题，在节点上加上“:empty”，自定义其属性就可以达到在节点内没内容的时候将此模板隐掉。 12345678910111213.alert&#123; background-color: beige; border: 2px solid rgb(150,150,150); border-radius: 5px; padding: 5px 10px; display: inline-block; width:200px; height:200px;&#125;.alert:empty &#123; display: none&#125; 小示例： :empty控制alert的小示例 4.响应式布局 （1）px、em、rem 首先我要介绍一下rem这个单位，在此之前，提一下常用的两个单位： PX &amp; EM px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册) em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册) 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。为了简化font-size的换算，我们在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px62.5%=10px, 这样 10px=1em, 也就是说我们只需要将原来的px数值除以10，然后换上em作为单位就行了。所以我们在css里**任何关于px***单位的书写都可以换成em了。 在这里特别注明，因为em会继承父级元素的字体大小，所以要小心字体大小的重复定义，因为这个em会不断计算下去。 解决了以上确定，又有一个REM的单位粗线了，它也是一个相对单位（root em），相对于根EM的单位，它就使我们在嵌套里设定字体大小时，仍然是相对大小，相对html根元素大小，我们可以只修改根元素的设定，就能成比例地调整整个页面。此属性支持所有浏览器，除了IE8及更早的。 （2）vh&amp;vw / vmin&amp;vmax 这几个都是长度单位，都和视口有关。 vh: 视口高度。 1vh = 当前浏览窗口高度/100 vw: 视口宽度。 1vw = 当前浏览窗口宽度/100 vmin,vmax及取浏览窗口长宽的小值和大值的百分之一 eg1：浏览窗口height=1600px,width=800px,则1vmin=8px 1vmax= 16px eg2：浏览窗口height=990px,width=1400px,则1vmin=9.9px 1vmax=14px 还有两个单位。 ex and ch? （3）calc() 说到响应式布局，还有一个很重要的属性，看起来很像函数的css属性–calc()。 先回忆一下平时我们写的盒子，为自适应大小，有时会设宽度为100%，但是这个盒子也蛮脆弱的，如果我们需要加个border、margin什么的，就很容易把它给撑破了。示例 cacl()可以动态计算值，给元素设定长度，让我们来看看它的特点： 1 calc(expression) //我们可以在其中进行加减乘除各种运算，但是运算符前后须有空格 2 运算时可以多种单位混用，我们前面才讲了的px、em、rem在这里可以一起用在一个运算表达式里。 至于它的兼容性，当然是很友好的。除了IE8及低版本，Opera mini，其他的均已支持。安卓浏览器4.4以后部分支持，5之后均已支持。 二、日常遇到的一些点 1.浏览器缩放引发的问题 一般在还原设计稿的时候，我们都会按照原稿的像素大小一比一还原，切出来的页码在测试了各个浏览器兼容调整之后似乎也没有什么问题了。但是某一天，近视的倩倩因为某网页字太小，按了command+将浏览器缩放比例调大了，然后也忘了将这个缩放比例调回来，看了会儿东西就开始工作了。然后某瞬间突然发现之前工作代码切的页面出现了怪异情况，有一些样式错乱发生，第一反应是修改的代码在哪写错了导致的（当然本宝宝最开始没有反应过来是因为啥），当我正在困惑为毛div的宽度变了，写的明明是206px，出来的实际宽度却是个205.81px时，把浏览器缩放变成100%，发现问题都没有了。🙄 在学习这个问题的时候，我要引入几个概念： （1） 屏幕分辨率（2） 设备像素（3） CSS像素 屏幕分辨率和设备像素是物理概念，而CSS像素是我们编程的时候所用的概念。 *屏幕分辨率和设备像素*的差异在于设备像素显示密度（density px）,这个密度值为1的时候，这两者互等。 $$ dp=(dpi/160ppi) $$ dpi标准为160 当浏览器不进行缩放时，$ css像素 = 实际像素 $ 但是当浏览器进行缩放时，由PX写的样式错乱，这里有一些解决方式： （1）禁止用户缩放页面，在meta里设置user-scalcable=0。（嗯，感觉酱紫不太好，像我这种近视就想看大字呢？） （2）少用px控制，多用响应式布局，给min-width,max-width之类，还有上文提过的，采用em、rem单位，并且用calc()自适应，酱紫就能解决这些问题。 2.文字超出点点点效果实现 三个属性实现：(注意给这个框一个宽度or最大宽度) 123white-space: nowrap;overflow:hidden;text-overflow:ellipsis white-space 选项有normal：默认。空白会被浏览器忽略。pre：空白会被浏览器保留。其行为方式类似 HTML 中的 pre标签。nowrap:文本不会换行，文本会在在同一行上继续，直到遇到 br标签为止。pre-wrap:保留空白符序列，但是正常地进行换行。pre-line:合并空白符序列，但是保留换行符。inherit:规定应该从父元素继承 white-space 属性的值。 text-overflow 选项有text-overflow: clip|ellipsis|string; 3.ie7 relative穿透 问题描述：在IE7浏览器中，发现一个容器里的某下拉框的z-index已经被设置到全文最大了，但仍被接下来的div给遮住了，哦多kei？ 产生原因：在IE浏览器中，定位元素会产生一个新的stacking context,并且从z-index的值为0开始，也就是说后面定位的节点（即给过属性值position：absolute/relative）会盖住前面的。 实例： 12345678910/!-- html --/&lt;div class=\"box1\" style=\"position:relative\"&gt; &lt;ul style=\"z-index:99999\" class=\"selectlist\"&gt; //'假装炒鸡高了，应该在最外层' &lt;li&gt;其实我是模拟一个下拉框里面的一个元素&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"box2\" style=\"position:relative\"&gt; &lt;div style=\"position:absolute;z-index:100\" class=\"innerbox\"&gt;&lt;/div&gt; //虽然z-index值很小，但是是在最上面&lt;/div&gt; 以上代码，会优先解释有定位元素的外层元素，selectlist的z-index是相对于它的父级，同理innerbox也是针对于它的父级，这两个index根本木有比较性。 解决方法：我们给需要比较的父级加上z-index，若这个值是box1&gt;box2，那么box1的层级始终是在box2上的。 4.推荐实用小工具 雪碧图在线生成","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"DarkMagic","slug":"DarkMagic","permalink":"http://yoursite.com/tags/DarkMagic/"}]},{"title":"我们用过的packageJson","date":"2016-08-27T05:18:57.000Z","path":"2016/08/27/我们用过的packageJson/","text":"参考文章：npm模块管理器、package.json文件、why npm scripts、node.js命令行程序开发教程 1.package.json是？ 1.1概述 1.2创建使用 1.3常用的 2.被忽略的一些点 2.1 构建项目的scripts 2.2 bin 3.一些其他小常识补充 3.1 gulp&amp;grunt… 3.2 常见盲区 1 package.json是？ package.json对很多前端童鞋来讲都不陌生，在各种项目构建管理潮流的大军中，这个就是赶潮流的入口文件，然而它是什么呢？接下来我将从我理解的角度来介绍它。 1.1 概述 从某个时间开始nodejs开始🔥，我们便发现每个项目的根目录或者前端开发文件的根目录都离不开package.json这个文件了，因为有它我们可以在项目里npm install。这个json文件定义了我们这个项目所需要的各种模块以及项目的配置信息。而我以上说的npm install就是按照这个信息来进行的一系列配置安装。 npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。 1.2 创建使用使用npm init按照提示的一步步键入就可以创建一个最基本的package.json文件了。当然我们也可以手动创建文件，写入相应的东西。1.3 常用的 接下来我们要往我们的项目里添加依赖包了，很明显“devDependencies”和“dependencies”这两个对象里面是存放了一些包名的，这些包就是我们在npm install时下载的资源，它们名字比较像，记住前面有dev的是我们在开发过程中需要的包，相当于工具，发布项目的时候是不需要发布它们的，而后者则是项目运行所需要的。包名后面跟着版本号这里就不详细说明了。 1234567891011121314151617181920212223242526&#123; \"name\": \"npmPackage\", \"version\": \"1.0.0\", \"description\": \"倩倩的npm模块管理器练习\", \"main\": \"\", \"author\": \"linqian\", \"license\": \"\", \"devDependencies\": &#123; \"graceful-fs\": \"^4.1.2\", \"live-server\": \"^1.1.0\", \"npm-run-all\": \"^3.0.0\", \"webpack\": \"^1.12.0\" &#125;, \"dependencies\": &#123; \"JSON2\": \"^0.1.0\", \"augment\": \"^4.3.0\", \"css-loader\": \"^0.17.0\", \"ejs-loader\": \"^0.2.1\", \"es5-shim\": \"^4.4.1\", \"expose-loader\": \"^0.7.0\", \"jquery\": \"^1.11.3\", \"shelljs\": \"^0.7.3\", \"style-loader\": \"^0.12.3\", \"underscore\": \"^1.8.3\" &#125;&#125; 2 那些被我们忽略的 查看我们的项目，发现在package.json里大多只利用了依赖包，而其他很多字段都没有用上，比如”scripts”、”bin”、”config”、”style”等，这里我参照了package.json文件学习，我觉得并不是只有需要的时候才去学习，而是首先了解这一套，在用到它的时候还会有更多花样和解决思路。 2.1 构建项目的scripts 2.1.1 使用 scripts指定了运行脚本命令的npm命令行缩写，运行使用npm run 名字，比如在如下的设置里，分别使用npm run test/npm run serve/npm run startRepl来执行相应的指令。12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;node ./src/testEcho.js&quot;, &quot;serve&quot;: &quot;live-server dist/ --port=9090&quot;, &quot;startRepl&quot;: &quot;node repl.js&quot;&#125; npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。 现在我们在执行了以下安装命令后（或者是安装了devDependencies里的包后）1$ npm install eslint --save-dev 123456&quot;devDependencies&quot;: &#123; &quot;eslint&quot;: &quot;^1.10.3&quot;&#125;,&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint .&quot;&#125; 则可在scripts属性里的命令中不带路径地引用eslint这个脚本。 scripts属性中的命令可以是: 编写的一行直接使用某npm包进行的操作 由命令编写的一个文件 一连串的操作指令 npm run为每条命令提供了“pre”和“post”两个钩子，还是拿示例说明，我现在如果运行npm run lint，则会在lint命令执行前执行“prelint”,在lint命令执行后执行“postlint”。12345678&quot;devDependencies&quot;: &#123; &quot;eslint&quot;: &quot;^1.10.3&quot;&#125;,&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint .&quot;, &quot;prelint&quot;: &quot;hello&quot;, &quot;postlint&quot;: &quot;done&quot;&#125; 当然除了利用上述钩子之外，我们还可以自己写一些东西将命令们给“钩”起来，这得益于Linux系统的管道命令。 2.1.2 linux系统的管道命令 在scripts里是支持书写Linux系统下的各种命令的， 12&quot;build-js&quot;: &quot;browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js&quot;,&quot;uglify&quot;: &quot;mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js&quot; “&lt;” &emsp;将文件的内容输入到一个命令 “&gt;” &emsp;将操作的输出重定向到另一个文件 “|” &emsp;&nbsp;将一个命令的输出重定向到另一个命令 “&amp;” &emsp;并行执行几个任务 “&amp;&amp;” &nbsp;顺序调用任务(当前面执行成功后，后面的命令才继续) “；” &emsp;顺序调用任务(不管前面成功没有，后面的命令继续) 这里有个很好的scripts示例，参照此我们在scripts里面书写指令就基本能满足我们的日常开发需求（这里我指的是能够替换gulp、grunt、webpack之类的工具） 示例部分代码12345678910111213141516171819&quot;scripts&quot;: &#123; &quot;clean&quot;: &quot;rm -f dist/&#123;css/*,js/*,images/*&#125;&quot;, &quot;autoprefixer&quot;: &quot;postcss -u autoprefixer -r dist/css/*&quot;, &quot;scss&quot;: &quot;node-sass --output-style compressed -o dist/css src/scss&quot;, &quot;lint&quot;: &quot;eslint src/js&quot;, &quot;uglify&quot;: &quot;mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js &amp;&amp; uglifyjs src/js/*.js -m -c -o dist/js/app.min.js&quot;, &quot;imagemin&quot;: &quot;imagemin src/images/* -o dist/images&quot;, &quot;icons&quot;: &quot;svgo -f src/images/icons &amp;&amp; mkdir -p dist/images &amp;&amp; svg-sprite-generate -d src/images/icons -o dist/images/icons.svg&quot;, &quot;serve&quot;: &quot;browser-sync start --server --files &apos;dist/css/*.css, dist/js/*.js, **/*.html, !node_modules/**/*.html&apos;&quot;, &quot;build:css&quot;: &quot;npm run scss &amp;&amp; npm run autoprefixer&quot;, &quot;build:js&quot;: &quot;npm run lint &amp;&amp; npm run uglify&quot;, &quot;build:images&quot;: &quot;npm run imagemin &amp;&amp; npm run icons&quot;, &quot;build:all&quot;: &quot;npm run build:css &amp;&amp; npm run build:js &amp;&amp; npm run build:images&quot;, &quot;watch:css&quot;: &quot;onchange &apos;src/scss&apos; -- npm run build:css&quot;, &quot;watch:js&quot;: &quot;onchange &apos;src/js&apos; -- npm run build:js&quot;, &quot;watch:images&quot;: &quot;onchange &apos;src/images&apos; -- npm run build:images&quot;, &quot;watch:all&quot;: &quot;npm-run-all -p serve watch:css watch:js watch:images&quot;, &quot;postinstall&quot;: &quot;npm run build:all &amp;&amp; npm run watch:all&quot; &#125; 具体命令行怎么写可以参照npm包官网，有比较清晰完整的说明。比如拿上面的sass举例，找到相应文档 同时有一点要说的，并不是一定要用scripts替换gulp/webpack之类的，他们也是可以共存的，想象一下，加入你的工程在启动的时候需要执行多个gulp流，实在是不方便又不好再改，可以将几个命令集成到一个scripts指令中，是会带来很大便利的。 2.2 binbin项用来指定各个内部命令对应的可执行文件的位置。123&quot;bin&quot;: &#123; &quot;someTool&quot;: &quot;./bin/someTool.js&quot;&#125;上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。所以可以像下面这么写。123scripts: &#123; &quot;start&quot;: &quot;node someTool&quot;&#125;3 一些其他小常识补充3.1 gulp&amp;grunt… 前端自动化工程化的一发不可收拾，给我们的开发带来巨大益处的同时也是有着诸多不便的。 对插件作者的依赖 令人沮丧的调试 脱节的文档 ####问题 1：对插件作者的依赖 首先我们看npm插件的对比 从上图可以看到，Gulp 有将近 2,100 个插件；Grunt 有将近 5,400 个；而 npm 则提供了 227,000 多个包，同时还以每天 400 多个的速度在持续增加。 在使用npm scripts时，你无需再搜索Grunt或是Gulp插件；只需从227,000多个npm包中选择就行了。公平地说，如果所需要的 Grunt 或是 Gulp 插件不存在，你当然可以直接使用 npm packages。不过，这样就无法再针对这个特定的任务使用 Gulp 或是 Grunt 了。 ####问题 2：令人沮丧的调试 如果集成失败了，那么在 Grunt 和 Gulp 中调试是一件令人沮丧的事情。因为你面对的是一个额外的抽象层，对于任何 Bug 来说都有可能存在更多潜在的原因： 基础工具出问题了么？ Grunt/Gulp 插件出问题了么？ 配置出问题了么？ 使用的版本是不是不兼容？ 使用 npm scripts 可以消除上面的第 2 点，我发现第 3 点也很少会出现，因为我通常都是直接调用工具的命令行接口。最后，第 4 点也很少出现，因为我通过直接使用 npm 而不是任务运行器的抽象减少了项目中包的数量。 ####问题 3：脱节的文档 一般来说，我所需要的核心工具的文档质量总是要比与之相关的 Grunt 和 Gulp 插件的好。比如说，如果使用了 gulp-eslint ，那么我就要在gulp-eslint文档与 ESLint 网站之间来回切换；不得不在插件与插件所抽象的工具之间来回切换上下文。Gulp 与 Grunt 的问题在于：光理解所用的工具是远远不够的。Gulp 与 Grunt 要求你还得理解插件的抽象。 更多内容请参照 why npm scripts当然npm scripts不是一定要替换掉以上工具的，它可以和gulp共同使用，毕竟我们的最终目标都是更加方便快捷清晰地开发以及管理项目。 3.2 常见盲区 ① 经常看到一些东西很眼熟，但是不清楚是干啥的，比如process.env之类的，就搜了一下： nodejs的process模块 ② 一个小疑惑，大家发现 USER 和 HOME 这类的环境变量用的比较多，我们编写流的时候是不是可以直接利用它们做些手脚呢？试试在本地输入下面命令：12echo $&#123;USER&#125;echo $&#123;HOME&#125; That’s all 谢谢观看 回到顶部","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]}]